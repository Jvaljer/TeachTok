"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setData = void 0;
const get_js_1 = __importDefault(require("lodash/get.js"));
const set_js_1 = __importDefault(require("lodash/set.js"));
const has_js_1 = __importDefault(require("lodash/has.js"));
const errors_1 = require("@feathersjs/errors");
const getItemsIsArray_1 = require("../utils/getItemsIsArray");
const defaultOptions = {
    allowUndefined: false,
    overwrite: true
};
function setData(from, to, _options) {
    const options = Object.assign({}, defaultOptions, _options);
    return (context) => {
        var _a;
        const { items } = (0, getItemsIsArray_1.getItemsIsArray)(context);
        if (!(0, has_js_1.default)(context, from)) {
            if (!((_a = context.params) === null || _a === void 0 ? void 0 : _a.provider) || options.allowUndefined === true) {
                return context;
            }
            if (!options.overwrite && items.every((item) => (0, has_js_1.default)(item, to))) {
                return context;
            }
            throw new errors_1.Forbidden(`Expected field ${from.toString()} not available`);
        }
        const val = (0, get_js_1.default)(context, from);
        items.forEach((item) => {
            let overwrite;
            if (typeof options.overwrite === "function") {
                overwrite = options.overwrite(item, context);
            }
            else {
                overwrite = options.overwrite;
            }
            if (!overwrite && (0, has_js_1.default)(item, to)) {
                return;
            }
            (0, set_js_1.default)(item, to, val);
        });
        return context;
    };
}
exports.setData = setData;
