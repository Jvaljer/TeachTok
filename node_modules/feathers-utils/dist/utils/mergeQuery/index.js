"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeQuery = void 0;
const get_js_1 = __importDefault(require("lodash/get.js"));
const has_js_1 = __importDefault(require("lodash/has.js"));
const isEmpty_js_1 = __importDefault(require("lodash/isEmpty.js"));
const isEqual_js_1 = __importDefault(require("lodash/isEqual.js"));
const merge_js_1 = __importDefault(require("lodash/merge.js"));
const set_js_1 = __importDefault(require("lodash/set.js"));
const uniqWith_js_1 = __importDefault(require("lodash/uniqWith.js"));
const mergeArrays_1 = require("./mergeArrays");
const filterQuery_1 = require("../filterQuery");
const errors_1 = require("@feathersjs/errors");
const hasOwnProperty = (obj, key) => {
    return Object.prototype.hasOwnProperty.call(obj, key);
};
function handleArray(target, source, key, options) {
    const targetVal = (0, get_js_1.default)(target, key);
    const sourceVal = (0, get_js_1.default)(source, key);
    if (!sourceVal && !targetVal) {
        return;
    }
    const handle = (0, get_js_1.default)(options, ["handle", ...key], options.defaultHandle);
    const arr = (0, mergeArrays_1.mergeArrays)(targetVal, sourceVal, handle, key, options.actionOnEmptyIntersect);
    (0, set_js_1.default)(target, key, arr);
}
function handleCircular(target, source, prependKey, options) {
    if (target === null || target === void 0 ? void 0 : target.$or) {
        target.$or = cleanOr(target.$or);
        if (!target.$or) {
            delete target.$or;
        }
    }
    if (source === null || source === void 0 ? void 0 : source.$or) {
        source.$or = cleanOr(source.$or);
        if (!source.$or) {
            delete source.$or;
        }
    }
    if (target === null || target === void 0 ? void 0 : target.$and) {
        target.$and = cleanAnd(target.$and);
        if (!target.$and) {
            delete target.$and;
        }
    }
    if (source === null || source === void 0 ? void 0 : source.$and) {
        source.$and = cleanAnd(source.$and);
        if (!source.$and) {
            delete source.$and;
        }
    }
    if (!(0, has_js_1.default)(source, prependKey)) {
        return;
    }
    if (!(0, has_js_1.default)(target, prependKey)) {
        (0, set_js_1.default)(target, prependKey, (0, get_js_1.default)(source, prependKey));
        return;
    }
    const { defaultHandle, actionOnEmptyIntersect } = options;
    if (defaultHandle === "target") {
        return;
    }
    const getTargetVal = () => {
        return (prependKey.length > 0) ? (0, get_js_1.default)(target, prependKey) : target;
    };
    const getSourceVal = () => {
        return (prependKey.length > 0) ? (0, get_js_1.default)(source, prependKey) : source;
    };
    const targetVal = getTargetVal();
    const sourceVal = getSourceVal();
    if ((0, isEqual_js_1.default)(targetVal, sourceVal)) {
        return;
    }
    if (defaultHandle === "source") {
        (0, set_js_1.default)(target, prependKey, sourceVal);
        return;
    }
    if (targetVal === null || sourceVal === null) {
        (0, set_js_1.default)(target, prependKey, sourceVal);
        return;
    }
    const typeOfTargetVal = typeof targetVal;
    if (["boolean"].includes(typeOfTargetVal)) {
        if (defaultHandle === "intersect") {
            actionOnEmptyIntersect(target, source, prependKey);
        }
        (0, set_js_1.default)(target, prependKey, sourceVal);
        return;
    }
    const typeOfSourceVal = typeof sourceVal;
    const isTargetSimple = ["string", "number"].includes(typeOfTargetVal);
    const isSourceSimple = ["string", "number"].includes(typeOfSourceVal);
    if (isTargetSimple || isSourceSimple) {
        if (isTargetSimple && isSourceSimple) {
            if (defaultHandle === "combine") {
                (0, set_js_1.default)(target, prependKey, { $in: [...new Set([targetVal, sourceVal])] });
                return;
            }
            else if (defaultHandle === "intersect") {
                actionOnEmptyIntersect(target, source, prependKey);
            }
            else {
                throw new Error("should not reach here");
            }
        }
        else if (hasOwnProperty(targetVal, "$in") || hasOwnProperty(sourceVal, "$in")) {
            const targetHasIn = hasOwnProperty(targetVal, "$in");
            const $in = (targetHasIn) ? targetVal["$in"] : sourceVal["$in"];
            const otherVal = (isTargetSimple) ? targetVal : sourceVal;
            if ($in.length === 1 && (0, isEqual_js_1.default)($in[0], otherVal)) {
                (0, set_js_1.default)(target, prependKey, otherVal);
                return;
            }
            else if (defaultHandle === "combine") {
                if (!$in.some((x) => (0, isEqual_js_1.default)(x, otherVal))) {
                    $in.push(otherVal);
                }
                (0, set_js_1.default)(target, `${prependKey}.$in`, $in);
                return;
            }
            else if (defaultHandle === "intersect") {
                if ($in.some((x) => (0, isEqual_js_1.default)(x, otherVal))) {
                    (0, set_js_1.default)(target, prependKey, otherVal);
                }
                else {
                    actionOnEmptyIntersect(target, source, prependKey);
                }
                return;
            }
            return;
        }
    }
    const isTargetArray = Array.isArray(targetVal);
    const isSourceArray = Array.isArray(sourceVal);
    if (isTargetArray && isSourceArray) {
        const key = prependKey[prependKey.length - 1];
        if (key === "$or") {
            if (defaultHandle === "combine") {
                const newVals = sourceVal.filter((x) => !targetVal.some((y) => (0, isEqual_js_1.default)(x, y)));
                targetVal.push(...newVals);
            }
            else if (defaultHandle === "intersect") {
                // combine into "$and"
                const targetParent = getParentProp(target, prependKey);
                const sourceParent = getParentProp(source, prependKey);
                targetParent.$and = targetParent.$and || [];
                targetParent.$and.push({ $or: targetVal }, { $or: sourceVal });
                targetParent.$and = cleanAnd(targetParent.$and);
                if (!targetParent.$and) {
                    delete targetParent.$and;
                }
                delete targetParent.$or;
                delete sourceParent.$or;
                handleCircular(target, source, [...prependKey, "$and"], options);
                return;
            }
            return;
        }
        else if (key === "$and") {
            if (defaultHandle === "combine") {
                // combine into "$or"
                const targetParent = getParentProp(target, prependKey);
                const sourceParent = getParentProp(source, prependKey);
                targetParent.$or = targetParent.$or || [];
                targetParent.$or.push({ $and: targetVal }, { $and: sourceVal });
                targetParent.$or = cleanOr(targetParent.$or);
                if (!targetParent.$or) {
                    delete targetParent.$or;
                }
                delete targetParent.$and;
                delete sourceParent.$and;
                handleCircular(target, source, [...prependKey, "$or"], options);
                return;
            }
            else if (defaultHandle === "intersect") {
                const newVals = sourceVal.filter((x) => !targetVal.some((y) => (0, isEqual_js_1.default)(x, y)));
                targetVal.push(...newVals);
                return;
            }
        }
        else if (key === "$in") {
            if (defaultHandle === "combine") {
                let $in = targetVal.concat(sourceVal);
                $in = [...new Set($in)];
                (0, set_js_1.default)(target, prependKey, $in);
                return;
            }
            else if (defaultHandle === "intersect") {
                const $in = targetVal.filter((x) => sourceVal.some((y) => (0, isEqual_js_1.default)(x, y)));
                if ($in.length === 0) {
                    actionOnEmptyIntersect(target, source, prependKey);
                }
                else if ($in.length === 1) {
                    (0, set_js_1.default)(target, prependKey.slice(0, -1), $in[0]);
                    return;
                }
                else {
                    (0, set_js_1.default)(target, prependKey, $in);
                }
            }
            return;
        }
        (0, set_js_1.default)(target, prependKey, sourceVal);
        return;
    }
    if (typeOfTargetVal !== "object" || typeOfSourceVal !== "object") {
        (0, set_js_1.default)(target, prependKey, sourceVal);
        return;
    }
    // both are objects
    const sourceKeys = Object.keys(sourceVal);
    for (let i = 0, n = sourceKeys.length; i < n; i++) {
        const key = sourceKeys[i];
        handleCircular(target, source, [...prependKey, key], options);
    }
}
function makeDefaultOptions(options) {
    options = options || {};
    options.defaultHandle = options.defaultHandle || "combine";
    options.useLogicalConjunction =
        (Object.prototype.hasOwnProperty.call(options, "useLogicalConjunction"))
            ? options.useLogicalConjunction
            : false;
    options.actionOnEmptyIntersect = options.actionOnEmptyIntersect || (() => {
        throw new errors_1.Forbidden("You're not allowed to make this request");
    });
    options.handle = options.handle || {};
    if (options.defaultHandle === "intersect") {
        options.handle.$select = options.handle.$select || "intersectOrFull";
    }
    return options;
}
function mergeQuery(target, source, options) {
    const fullOptions = makeDefaultOptions(options);
    const { filters: targetFilters, query: targetQuery } = (0, filterQuery_1.filterQuery)(target, {
        operators: fullOptions.operators,
        service: fullOptions.service
    });
    if (target.$limit) {
        targetFilters.$limit = target.$limit;
    }
    let { 
    // eslint-disable-next-line prefer-const
    filters: sourceFilters, query: sourceQuery } = (0, filterQuery_1.filterQuery)(source, {
        operators: fullOptions.operators,
        service: fullOptions.service
    });
    if (source.$limit) {
        sourceFilters.$limit = source.$limit;
    }
    //#region filters
    if (target &&
        !Object.prototype.hasOwnProperty.call(target, "$limit") &&
        Object.prototype.hasOwnProperty.call(targetFilters, "$limit")) {
        delete targetFilters.$limit;
    }
    if (source &&
        !Object.prototype.hasOwnProperty.call(source, "$limit") &&
        Object.prototype.hasOwnProperty.call(sourceFilters, "$limit")) {
        delete sourceFilters.$limit;
    }
    handleArray(targetFilters, sourceFilters, ["$select"], fullOptions);
    // remaining filters
    delete sourceFilters["$select"];
    (0, merge_js_1.default)(targetFilters, sourceFilters);
    //#endregion
    //#region '$or' / '$and'
    if ((options === null || options === void 0 ? void 0 : options.useLogicalConjunction) &&
        (options.defaultHandle === "combine" ||
            options.defaultHandle === "intersect") &&
        !(0, isEmpty_js_1.default)(targetQuery)) {
        const logicalOp = (options.defaultHandle === "combine")
            ? "$or"
            : "$and";
        if (Object.prototype.hasOwnProperty.call(sourceQuery, logicalOp)) {
            // omit '$or'/'$and' and put all other props into '$or'/'$and'
            const andOr = sourceQuery[logicalOp];
            delete sourceQuery[logicalOp];
            andOr.push(sourceQuery);
            sourceQuery = { [logicalOp]: andOr };
        }
        else {
            sourceQuery = { [logicalOp]: [sourceQuery] };
        }
    }
    //#endregion
    const keys = Object.keys(sourceQuery);
    for (let i = 0, n = keys.length; i < n; i++) {
        const key = keys[i];
        handleCircular(targetQuery, sourceQuery, [key], fullOptions);
    }
    const result = Object.assign({}, targetFilters, targetQuery);
    return result;
}
exports.mergeQuery = mergeQuery;
function getParentProp(target, path) {
    if (path.length <= 1) {
        return target;
    }
    const pathOneUp = path.slice(0, -1);
    return (0, get_js_1.default)(target, pathOneUp);
}
function cleanOr(target) {
    if (!target || !Array.isArray(target) || target.length <= 0) {
        return target;
    }
    if (target.some(x => (0, isEmpty_js_1.default)(x))) {
        return undefined;
    }
    else {
        return arrayWithoutDuplicates(target);
    }
}
function cleanAnd(target) {
    if (!target || !Array.isArray(target) || target.length <= 0) {
        return target;
    }
    if (target.every(x => (0, isEmpty_js_1.default)(x))) {
        return undefined;
    }
    else {
        target = target.filter(x => !(0, isEmpty_js_1.default)(x));
        return arrayWithoutDuplicates(target);
    }
}
function arrayWithoutDuplicates(target) {
    if (!target || !Array.isArray(target)) {
        return target;
    }
    return (0, uniqWith_js_1.default)(target, isEqual_js_1.default);
}
