import type { Application, HookContext, Service } from "@feathersjs/feathers";
export declare type Path = Array<string | number>;
export declare type MaybeArray<T> = T | T[];
export declare type Promisable<T> = T | Promise<T>;
export declare type HookType = "before" | "after" | "error";
export declare type ServiceMethodName = "find" | "get" | "create" | "update" | "patch" | "remove";
export declare type ReturnSyncHook = (context: HookContext) => HookContext;
export declare type ReturnAsyncHook = (context: HookContext) => Promise<HookContext>;
export declare type Handle = "target" | "source" | "combine" | "intersect" | "intersectOrFull";
export declare type FirstLast = "first" | "last";
export declare type Predicate<T = any> = (item: T) => boolean;
export declare type PredicateWithContext<T = any> = (item: T, context: HookContext) => boolean;
export interface HookSetDataOptions {
    allowUndefined?: boolean;
    overwrite?: boolean | PredicateWithContext;
}
export interface AddHookOptions {
    types: HookType[];
    methods: ServiceMethodName[];
    orderByType: Record<HookType, FirstLast>;
    whitelist?: string[];
    blacklist?: string[];
}
export interface HookRunPerItemOptions {
    wait?: boolean;
}
export interface RemoveRelatedOptions<S = Record<string, any>> {
    service: keyof S;
    keyThere: string;
    keyHere: string;
    blocking?: boolean;
}
export interface CreateRelatedOptions<S = Record<string, any>> {
    service: keyof S;
    multi?: boolean;
    data: (item: any, context: HookContext) => Promisable<Record<string, any>>;
    createItemsInDataArraySeparately?: boolean;
}
export declare type OnDeleteAction = "cascade" | "set null";
export interface OnDeleteOptions {
    keyThere: string;
    keyHere: string;
    onDelete: OnDeleteAction;
    blocking?: boolean;
}
export interface InitDebounceMixinOptions {
    default: Partial<DebouncedStoreOptions>;
    blacklist: string[];
    [key: string]: unknown;
}
export declare type DebouncedFunctionApp = (app?: Application) => void | Promise<void>;
export interface DebouncedStoreOptions {
    leading: boolean;
    maxWait: number | undefined;
    trailing: boolean;
    wait: number;
}
export interface PushSetOptions {
    unique?: boolean;
}
export declare type ActionOnEmptyIntersect = (target: unknown, source: unknown, prependKey: Path) => void;
export interface MergeQueryOptions<T> extends FilterQueryOptions<T> {
    defaultHandle: Handle;
    actionOnEmptyIntersect: ActionOnEmptyIntersect;
    useLogicalConjunction: boolean;
    handle?: {
        [key: string]: Handle;
    };
}
export interface FilterQueryOptions<T> {
    service?: Service<T>;
    operators?: string[];
    filters?: string[];
}
export interface PlainFilterQueryOptions {
    operators?: string[];
    filters?: string[];
}
export interface FilterQueryResult {
    filters: Record<string, unknown>;
    query: Record<string, unknown>;
    paginate?: unknown;
    [key: string]: unknown;
}
export interface GetItemsIsArrayResult<T = any> {
    items: T[];
    isArray: boolean;
}
