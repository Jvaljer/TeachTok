"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DebouncedStore = exports.makeDefaultOptions = void 0;
const debounce_js_1 = __importDefault(require("lodash/debounce.js"));
const makeDefaultOptions = () => {
    return {
        leading: false,
        maxWait: undefined,
        trailing: true,
        wait: 100
    };
};
exports.makeDefaultOptions = makeDefaultOptions;
class DebouncedStore {
    constructor(app, options) {
        this._app = app;
        this._options = Object.assign((0, exports.makeDefaultOptions)(), options);
        this._queueById = {};
        this._isRunningById = {};
        //this._waitingById = {};
        this.add = this.debounceById(this.unbounced, this._options.wait, {
            leading: this._options.leading,
            maxWait: this._options.maxWait,
            trailing: this._options.trailing
        });
    }
    unbounced(id, action) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._queueById[id] === undefined) {
                return;
            }
            delete this._queueById[id];
            this._isRunningById[id] = true;
            yield action(this._app);
            delete this._isRunningById[id];
        });
    }
    debounceById(func, wait, options) {
        return (id, action) => {
            if (typeof this._queueById[id] === "function") {
                return this._queueById[id](id, action);
            }
            this._queueById[id] = (0, debounce_js_1.default)((id, action) => {
                this.unbounced(id, action);
            }, wait, Object.assign(Object.assign({}, options), { leading: false })); // leading required for return promise
            return this._queueById[id](id, action);
        };
    }
    cancel(id) {
        delete this._queueById[id];
    }
}
exports.DebouncedStore = DebouncedStore;
