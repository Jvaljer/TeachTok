"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const multer_1 = __importDefault(require("multer"));
const express_1 = __importDefault(require("@feathersjs/express"));
const assets_nedb_class_1 = require("./assets-nedb.class");
const assets_mongodb_class_1 = require("./assets-mongodb.class");
const assets_nedb_model_1 = __importDefault(require("../../models/assets-nedb.model"));
const assets_hooks_1 = __importDefault(require("./assets.hooks"));
const objectid_1 = __importDefault(require("../../utils/objectid"));
const multer_gridfs_storage_1 = require("multer-gridfs-storage");
const mongodb_1 = require("mongodb");
function setupDiskStorage(app) {
    if (!fs_1.default.existsSync(app.get('uploads'))) {
        fs_1.default.mkdirSync(app.get('uploads'), { recursive: true });
    }
    if (!fs_1.default.existsSync(path_1.default.join(app.get('uploads'), 'assets'))) {
        fs_1.default.mkdirSync(path_1.default.join(app.get('uploads'), 'assets'), { recursive: true });
    }
    const storage = multer_1.default.diskStorage({
        destination: function (req, file, cb) {
            cb(null, path_1.default.join(app.get('uploads'), 'assets'));
        },
        filename: function (req, file, cb) {
            cb(null, `${req.id}/${file.fieldname}`);
        },
    });
    return storage;
}
function setupGridFsStorage(app) {
    const storage = new multer_gridfs_storage_1.GridFsStorage({ db: app.get('mongoClient') });
    return storage;
}
function default_1(app) {
    if (app.get('database') === 'nedb') {
        const options = {
            Model: (0, assets_nedb_model_1.default)(app),
            paginate: app.get('paginate'),
            multi: true,
            whitelist: ['$not', '$and'],
        };
        // Initialize our service with any options it requires
        app.use('/assets', new assets_nedb_class_1.Assets(options, app));
    }
    else if (app.get('database') === 'mongodb') {
        const options = {
            paginate: app.get('paginate'),
            multi: true,
            whitelist: ['$not', '$and'],
        };
        // Initialize our service with any options it requires
        app.use('/assets', new assets_mongodb_class_1.Assets(options, app));
    }
    else {
        throw new Error('Invalid database type: only "nedb" or "mongodb" are currently supported');
    }
    const allowedExtensions = app.get('whitelist').assets || ['jpg', 'jpeg', 'png', 'wav'];
    function fileFilter(req, file, cb) {
        const accept = allowedExtensions === '*' ||
            (!!file.fieldname.split('.').pop() &&
                allowedExtensions.includes(file.fieldname.split('.').pop()));
        cb(null, accept);
    }
    // Get our initialized service so that we can register hooks
    const useGridfs = app.get('database') === 'mongodb' && app.get('gridfs');
    const service = app.service('assets');
    const h = (0, assets_hooks_1.default)(app.get('authentication').enabled);
    service.hooks(h);
    const storage = useGridfs ? setupGridFsStorage(app) : setupDiskStorage(app);
    const upload = (0, multer_1.default)({ storage, fileFilter });
    const assetUpload = upload.any();
    const diskPostPrepare = (req, res, next) => {
        req.id = (0, objectid_1.default)();
        fs_1.default.mkdirSync(path_1.default.join(app.get('uploads'), 'assets', req.id), { recursive: true });
        next();
    };
    const diskPostResponse = function (req, res) {
        const response = {};
        if (Array.isArray(req.files)) {
            if (req.files.length > 0) {
                req.files.forEach(({ originalname, filename }) => {
                    response[originalname] = filename;
                });
            }
            else {
                res.status(400);
                response.error = `The request does not contain any valid file (accepted extensions: ${allowedExtensions})`;
            }
        }
        else {
            Object.entries(req.files || []).forEach(([name, x]) => {
                response[name] = x[0].filename;
            });
        }
        res.json(response);
    };
    const gridfsPostResponse = function (req, res) {
        const response = {};
        if (Array.isArray(req.files)) {
            const reqFiles = req.files;
            reqFiles.forEach(({ originalname, id, fieldname }) => {
                response[originalname] = `${id}/${fieldname}`;
            });
        }
        else {
            const reqFiles = req.files;
            Object.entries(reqFiles || []).forEach(([name, x]) => {
                response[name] = `${x[0].id}/${x[0].fieldname}`;
            });
        }
        res.json(response);
    };
    const postMiddlewares = [];
    if (app.get('authentication').enabled) {
        postMiddlewares.push(express_1.default.authenticate('jwt'));
    }
    if (!useGridfs) {
        postMiddlewares.push(diskPostPrepare);
    }
    postMiddlewares.push(assetUpload);
    postMiddlewares.push(useGridfs ? gridfsPostResponse : diskPostResponse);
    app.post('/assets/upload', ...postMiddlewares);
    const getAssetFileFromDisk = async (req, res) => {
        try {
            const filePath = path_1.default.join(app.get('uploads'), 'assets', req.params.id, req.params.filename);
            if (!fs_1.default.existsSync(filePath)) {
                return res.status(404).json({
                    code: 404,
                    err: 'file does not exist',
                });
            }
            return res.sendFile(filePath);
        }
        catch (error) {
            // eslint-disable-next-line no-console
            console.log('asset download error', error);
            return res.status(500).json({
                code: 500,
                err: 'Internal Server Error',
            });
        }
    };
    // eslint-disable-next-line consistent-return
    const getAssetFileFromGridfs = async (req, res) => {
        try {
            const bucket = app.get('mongoBucket');
            bucket.find({ _id: new mongodb_1.ObjectId(req.params.id) }).toArray((err, files) => {
                if (err || !files || files.length === 0) {
                    return res.status(404).json({
                        err: 'file does not exist',
                    });
                }
                return bucket.openDownloadStream(files[0]._id).pipe(res);
            });
        }
        catch (error) {
            return res.status(404).json({
                err: 'file does not exist',
            });
        }
    };
    const getMiddlewares = [];
    // if (app.get('authentication').enabled) {
    //   getMiddlewares.push(express.authenticate('jwt'));
    // }
    getMiddlewares.push(useGridfs ? getAssetFileFromGridfs : getAssetFileFromDisk);
    app.get('/assets/:id/:filename', ...getMiddlewares);
}
exports.default = default_1;
