"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const multer_1 = __importDefault(require("multer"));
const multer_gridfs_storage_1 = require("multer-gridfs-storage");
const mongodb_1 = require("mongodb");
const express_1 = __importDefault(require("@feathersjs/express"));
const models_nedb_class_1 = require("./models-nedb.class");
const models_mongodb_class_1 = require("./models-mongodb.class");
const models_nedb_model_1 = __importDefault(require("../../models/models-nedb.model"));
const models_hooks_1 = __importDefault(require("./models.hooks"));
const objectid_1 = __importDefault(require("../../utils/objectid"));
function fileFilterTFJS(req, file, cb) {
    const accept = ['model.json', 'model.weights.bin'].includes(file.fieldname) ||
        (file.fieldname.includes('shard') && file.fieldname.split('.').pop() === 'bin');
    cb(null, accept);
}
function fileFilterONNX(req, file, cb) {
    const accept = file.fieldname.split('.').pop() === 'onnx';
    cb(null, accept);
}
function setupModelService(app, modelType, useGridfs) {
    if (app.get('database') === 'nedb') {
        const options = {
            Model: (0, models_nedb_model_1.default)(app, modelType),
            paginate: app.get('paginate'),
            multi: true,
            whitelist: ['$not', '$and'],
        };
        // Initialize our service with any options it requires
        app.use(`/${modelType}-models`, new models_nedb_class_1.Models(options, app));
    }
    else if (app.get('database') === 'mongodb') {
        const options = {
            paginate: app.get('paginate'),
            multi: true,
            whitelist: ['$not', '$and'],
        };
        // Initialize our service with any options it requires
        app.use(`/${modelType}-models`, new models_mongodb_class_1.Models(options, app, modelType));
    }
    else {
        throw new Error('Invalid database type: only "nedb" or "mongodb" are currently supported');
    }
    // Get our initialized service so that we can register hooks
    const service = app.service(`${modelType}-models`);
    const h = (0, models_hooks_1.default)(app.get('authentication').enabled, modelType, useGridfs);
    service.hooks(h);
    return service;
}
function setupDiskStorage(app, modelType) {
    // Setup Model File upload
    if (!fs_1.default.existsSync(app.get('uploads'))) {
        fs_1.default.mkdirSync(app.get('uploads'), { recursive: true });
    }
    if (!fs_1.default.existsSync(path_1.default.join(app.get('uploads'), modelType))) {
        fs_1.default.mkdirSync(path_1.default.join(app.get('uploads'), modelType), { recursive: true });
    }
    const storage = multer_1.default.diskStorage({
        destination: function (req, file, cb) {
            cb(null, path_1.default.join(app.get('uploads'), modelType));
        },
        filename: function (req, file, cb) {
            cb(null, `${req.id}/${file.fieldname}`);
        },
    });
    return storage;
}
function setupGridFsStorage(app) {
    const storage = new multer_gridfs_storage_1.GridFsStorage({ db: app.get('mongoClient') });
    return storage;
}
exports.default = (modelType) => {
    const fileFilter = modelType === 'tfjs' ? fileFilterTFJS : fileFilterONNX;
    return function (app) {
        const useGridfs = app.get('database') === 'mongodb' && app.get('gridfs');
        const service = setupModelService(app, modelType, useGridfs);
        let storage;
        if (useGridfs) {
            storage = setupGridFsStorage(app);
        }
        else {
            storage = setupDiskStorage(app, modelType);
        }
        const upload = (0, multer_1.default)({ storage, fileFilter });
        const modelUpload = upload.any();
        const diskPostPrepare = (req, res, next) => {
            req.id = (0, objectid_1.default)();
            fs_1.default.mkdirSync(path_1.default.join(app.get('uploads'), modelType, req.id));
            next();
        };
        const diskPostResponse = function (req, res) {
            const response = [];
            if (Array.isArray(req.files)) {
                req.files.forEach(({ originalname, filename }) => {
                    response.push([originalname, filename]);
                });
            }
            else {
                Object.entries(req.files || []).forEach(([name, x]) => {
                    response.push([name, x[0].filename]);
                });
            }
            res.json(response);
        };
        const gridfsPostResponse = function (req, res) {
            const response = [];
            if (Array.isArray(req.files)) {
                const reqFiles = req.files;
                reqFiles.forEach(({ originalname, id }) => {
                    response.push([originalname, id]);
                });
            }
            else {
                const reqFiles = (req.files || []);
                Object.entries(reqFiles).forEach(([name, x]) => {
                    response.push([name, x[0].id]);
                });
            }
            res.json(response);
        };
        const postMiddlewares = [];
        if (app.get('authentication').enabled) {
            postMiddlewares.push(express_1.default.authenticate('jwt'));
        }
        if (!useGridfs) {
            postMiddlewares.push(diskPostPrepare);
        }
        postMiddlewares.push(modelUpload);
        postMiddlewares.push(useGridfs ? gridfsPostResponse : diskPostResponse);
        app.post(`/${modelType}-models/upload`, ...postMiddlewares);
        const getModelFileFromDisk = async (req, res) => {
            try {
                const model = await service.get(req.params.id, req.feathers);
                const foundFile = model.files.filter(([fname]) => fname === req.params.filename);
                if (foundFile.length === 1) {
                    const fileName = foundFile[0][1];
                    const filePath = path_1.default.join(app.get('uploads'), modelType, fileName);
                    if (!fs_1.default.existsSync(filePath)) {
                        return res.status(404).json({
                            err: 'file does not exist',
                        });
                    }
                    return res.sendFile(filePath);
                }
                else {
                    return res.status(404).json({
                        err: 'file does not exist',
                    });
                }
            }
            catch (error) {
                // eslint-disable-next-line no-console
                console.log('model download error', error);
                return res.status(404).json({
                    err: 'file does not exist',
                });
            }
        };
        // eslint-disable-next-line consistent-return
        const getModelFileFromGridfs = async (req, res) => {
            try {
                const bucket = app.get('mongoBucket');
                const model = await service.get(req.params.id, req.feathers);
                const foundFile = model.files.filter(([fname]) => fname === req.params.filename);
                if (foundFile.length === 1) {
                    const fileId = foundFile[0][1];
                    bucket.find({ _id: new mongodb_1.ObjectId(fileId) }).toArray((err, files) => {
                        if (err || !files || files.length === 0) {
                            return res.status(404).json({
                                err: 'file does not exist',
                            });
                        }
                        return bucket.openDownloadStream(files[0]._id).pipe(res);
                    });
                }
                else {
                    return res.status(404).json({
                        err: 'file does not exist',
                    });
                }
            }
            catch (error) {
                // eslint-disable-next-line no-console
                console.log('model download error', error);
                return res.status(404).json({
                    err: 'file does not exist',
                });
            }
        };
        const getMiddlewares = [];
        if (app.get('authentication').enabled) {
            getMiddlewares.push(express_1.default.authenticate('jwt'));
            // Actually check if the parent model is public or user!
        }
        getMiddlewares.push(useGridfs ? getModelFileFromGridfs : getModelFileFromDisk);
        app.get(`/${modelType}-models/:id/:filename`, 
        // TODO: add authorization
        ...getMiddlewares);
    };
};
