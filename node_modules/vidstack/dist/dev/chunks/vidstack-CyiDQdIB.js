import { b as isFunction, s as setAttribute, e as effect, l as listenEvent, c as isKeyboardClick, f as isTouchEvent, g as getScope, h as scoped, o as onDispose, j as setStyle, k as autoUpdate, m as computePosition, n as signal, p as animationFrameThrottle, q as computed } from './vidstack-CXruz14q.js';

function listen(target, type, handler) {
  if (!target)
    return;
  return listenEvent(target, type, handler);
}
function setAttributeIfEmpty(target, name, value) {
  if (!target.hasAttribute(name))
    target.setAttribute(name, value);
}
function setARIALabel(target, $label) {
  if (target.hasAttribute("aria-label") || target.hasAttribute("data-no-label"))
    return;
  if (!isFunction($label)) {
    setAttribute(target, "aria-label", $label);
    return;
  }
  function updateAriaDescription() {
    setAttribute(target, "aria-label", $label());
  }
  effect(updateAriaDescription);
}
function isElementParent(owner, node, test) {
  while (node) {
    if (node === owner) {
      return true;
    } else if (test?.(node)) {
      break;
    } else {
      node = node.parentElement;
    }
  }
  return false;
}
function onPress(target, handler) {
  listenEvent(target, "pointerup", (event) => {
    if (event.button === 0)
      handler(event);
  });
  listenEvent(target, "keydown", (event) => {
    if (isKeyboardClick(event))
      handler(event);
  });
}
function isTouchPinchEvent(event) {
  return isTouchEvent(event) && (event.touches.length > 1 || event.changedTouches.length > 1);
}
function requestScopedAnimationFrame(callback) {
  let scope = getScope(), id = window.requestAnimationFrame(() => {
    scoped(callback, scope);
    id = -1;
  });
  return () => void window.cancelAnimationFrame(id);
}
function cloneTemplate(template, length, onCreate) {
  let current, prev = template, parent = template.parentElement, content = template.content.firstElementChild, elements = [];
  if (!content && template.firstElementChild) {
    template.innerHTML = template.firstElementChild.outerHTML;
    template.firstElementChild.remove();
    content = template.content.firstElementChild;
  }
  if (content?.nodeType !== 1) {
    throw Error("[vidstack] template must contain root element");
  }
  for (let i = 0; i < length; i++) {
    current = document.importNode(content, true);
    onCreate?.(current, i);
    parent.insertBefore(current, prev.nextSibling);
    elements.push(current);
    prev = current;
  }
  onDispose(() => {
    for (let i = 0; i < elements.length; i++)
      elements[i].remove();
  });
  return elements;
}
function createTemplate(content) {
  const template = document.createElement("template");
  template.innerHTML = content;
  return template.content;
}
function cloneTemplateContent(content) {
  const fragment = content.cloneNode(true);
  return fragment.firstElementChild;
}
function autoPlacement(el, trigger, placement, {
  offsetVarName,
  xOffset,
  yOffset,
  ...options
}) {
  if (!el)
    return;
  const floatingPlacement = placement.replace(" ", "-").replace("-center", "");
  setStyle(el, "visibility", !trigger ? "hidden" : null);
  if (!trigger)
    return;
  const negateX = (x) => placement.includes("left") ? `calc(-1 * ${x})` : x, negateY = (y) => placement.includes("top") ? `calc(-1 * ${y})` : y;
  return autoUpdate(trigger, el, () => {
    computePosition(trigger, el, { placement: floatingPlacement, ...options }).then(({ x, y }) => {
      Object.assign(el.style, {
        top: `calc(${y + "px"} + ${negateY(
          yOffset ? yOffset + "px" : `var(--${offsetVarName}-y-offset, 0px)`
        )})`,
        left: `calc(${x + "px"} + ${negateX(
          xOffset ? xOffset + "px" : `var(--${offsetVarName}-x-offset, 0px)`
        )})`
      });
    });
  });
}
function hasAnimation(el) {
  const styles = getComputedStyle(el);
  return styles.animationName !== "none";
}
function createSlot(name) {
  const slot = document.createElement("slot");
  slot.name = name;
  return slot;
}
function useTransitionActive($el) {
  const $active = signal(false);
  effect(() => {
    const el = $el();
    if (!el)
      return;
    listenEvent(el, "transitionstart", () => $active.set(true));
    listenEvent(el, "transitionend", () => $active.set(false));
  });
  return $active;
}
function useResizeObserver($el, onResize) {
  function onElementChange() {
    const el = $el();
    if (!el)
      return;
    onResize();
    const observer = new ResizeObserver(animationFrameThrottle(onResize));
    observer.observe(el);
    return () => observer.disconnect();
  }
  effect(onElementChange);
}
function useRectCSSVars($root, $el, prefix) {
  useResizeObserver($el, () => {
    const root = $root(), el = $el();
    if (root && el)
      setRectCSSVars(root, el, prefix);
  });
}
function setRectCSSVars(root, el, prefix) {
  const rect = el.getBoundingClientRect();
  for (const side of ["top", "left", "bottom", "right"]) {
    setStyle(root, `--${prefix}-${side}`, `${rect[side]}px`);
  }
}
function useActive($el) {
  const $mouseEnter = useMouseEnter($el), $focusIn = useFocusIn($el);
  return computed(() => $mouseEnter() || $focusIn());
}
function useMouseEnter($el) {
  const $enter = signal(false);
  effect(() => {
    const el = $el();
    if (!el) {
      $enter.set(false);
      return;
    }
    listenEvent(el, "mouseenter", () => $enter.set(true));
    listenEvent(el, "mouseleave", () => $enter.set(false));
  });
  return $enter;
}
function useFocusIn($el) {
  const $focusIn = signal(false);
  effect(() => {
    const el = $el();
    if (!el) {
      $focusIn.set(false);
      return;
    }
    listenEvent(el, "focusin", () => $focusIn.set(true));
    listenEvent(el, "focusout", () => $focusIn.set(false));
  });
  return $focusIn;
}

export { createTemplate as a, useResizeObserver as b, cloneTemplateContent as c, useActive as d, useMouseEnter as e, useRectCSSVars as f, createSlot as g, cloneTemplate as h, isTouchPinchEvent as i, hasAnimation as j, autoPlacement as k, listen as l, setARIALabel as m, isElementParent as n, onPress as o, requestScopedAnimationFrame as r, setAttributeIfEmpty as s, useTransitionActive as u };
