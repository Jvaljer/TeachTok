import { q as computed, u as peek, e as effect, p as animationFrameThrottle, o as onDispose, t as isString } from './vidstack-DoOmgEfT.js';
import { e, c, t, A, l, D, x, a as o } from './vidstack-Bf6opHxk.js';

class SignalDirective extends c {
  constructor(part) {
    super(part);
    this.h = null;
    this.w = false;
    this.ra = null;
    this.w = part.type === t.ATTRIBUTE || part.type === t.BOOLEAN_ATTRIBUTE;
  }
  render(signal) {
    if (signal !== this.h) {
      this.disconnected();
      this.h = signal;
      if (this.isConnected)
        this.Si();
    }
    return this.h ? this.el(peek(this.h)) : A;
  }
  reconnected() {
    this.Si();
  }
  disconnected() {
    this.ra?.();
    this.ra = null;
  }
  Si() {
    if (!this.h)
      return;
    this.ra = effect(this.o.bind(this));
  }
  el(value) {
    return this.w ? l(value) : value;
  }
  hl(value) {
    this.setValue(this.el(value));
  }
  o() {
    {
      this.hl(this.h?.());
    }
  }
}
function $signal(compute) {
  return e(SignalDirective)(computed(compute));
}

class SlotObserver {
  constructor(_root, _callback) {
    this.Wj = _root;
    this.Ca = _callback;
    this.elements = /* @__PURE__ */ new Set();
    this.vf = animationFrameThrottle(this.ea.bind(this));
  }
  connect() {
    this.ea();
    const observer = new MutationObserver(this.vf);
    observer.observe(this.Wj, { childList: true, subtree: true });
    onDispose(() => observer.disconnect());
    onDispose(this.disconnect.bind(this));
  }
  disconnect() {
    this.elements.clear();
  }
  assign(template, slot) {
    if (template instanceof Node) {
      slot.textContent = "";
      slot.append(template);
    } else {
      D(template, slot);
    }
    if (!slot.style.display) {
      slot.style.display = "contents";
    }
    const el = slot.firstElementChild;
    if (!el)
      return;
    const classList = slot.getAttribute("data-class");
    if (classList)
      el.classList.add(...classList.split(" "));
  }
  ea(entries) {
    if (entries && !entries.some((e) => e.addedNodes.length))
      return;
    let changed = false, slots = this.Wj.querySelectorAll("slot");
    for (const slot of slots) {
      if (!slot.hasAttribute("name") || this.elements.has(slot))
        continue;
      this.elements.add(slot);
      changed = true;
    }
    if (changed)
      this.Ca(this.elements);
  }
}

let id = 0, slotIdAttr = "data-slot-id";
class SlotManager {
  constructor(_root) {
    this.Wj = _root;
    this.vf = animationFrameThrottle(this.ea.bind(this));
    this.slots = new SlotObserver(_root, this.ea.bind(this));
  }
  connect() {
    this.slots.connect();
    this.ea();
    const mutations = new MutationObserver(this.vf);
    mutations.observe(this.Wj, { childList: true });
    onDispose(() => mutations.disconnect());
  }
  ea() {
    for (const node of this.Wj.children) {
      if (node.nodeType !== 1)
        continue;
      const name = node.getAttribute("slot");
      if (!name)
        continue;
      node.style.display = "none";
      let slotId = node.getAttribute(slotIdAttr);
      if (!slotId) {
        node.setAttribute(slotIdAttr, slotId = ++id + "");
      }
      for (const slot of this.slots.elements) {
        if (slot.getAttribute("name") !== name || slot.getAttribute(slotIdAttr) === slotId) {
          continue;
        }
        const clone = document.importNode(node, true);
        if (name.includes("-icon"))
          clone.classList.add("vds-icon");
        clone.style.display = "";
        clone.removeAttribute("slot");
        this.slots.assign(clone, slot);
        slot.setAttribute(slotIdAttr, slotId);
      }
    }
  }
}

function Icon({ name, class: _class, state, paths, viewBox = "0 0 32 32" }) {
  return x`<svg
    class="${"vds-icon" + (_class ? ` ${_class}` : "")}"
    viewBox="${viewBox}"
    fill="none"
    aria-hidden="true"
    focusable="false"
    xmlns="http://www.w3.org/2000/svg"
    data-icon=${l(name ?? state)}
  >
    ${!isString(paths) ? $signal(paths) : o(paths)}
  </svg>`;
}

class IconsLoader {
  constructor(_root) {
    this.Wj = _root;
    this.Zj = {};
    this.bk = false;
    this.slots = new SlotObserver(_root, this.ck.bind(this));
  }
  connect() {
    this.slots.connect();
    onDispose(this.disconnect.bind(this));
  }
  load() {
    this.xe().then((icons) => {
      this.Zj = icons;
      this.bk = true;
      this.ck();
    });
  }
  disconnect() {
    for (const { slot } of this.dk()) {
      slot.textContent = "";
    }
  }
  *dk() {
    for (const iconName of Object.keys(this.Zj)) {
      const slotName = `${iconName}-icon`;
      for (const slot of this.slots.elements) {
        if (slot.name !== slotName)
          continue;
        yield { icon: this.Zj[iconName], slot };
      }
    }
  }
  ck() {
    if (!this.bk)
      return;
    for (const { icon, slot } of this.dk()) {
      this.slots.assign(icon, slot);
    }
  }
}

class LayoutIconsLoader extends IconsLoader {
  connect() {
    super.connect();
    const target = this.Wj.parentElement;
    if (!target)
      return;
    let dispose, observer = new IntersectionObserver((entries) => {
      if (!entries[0]?.isIntersecting)
        return;
      dispose?.();
      dispose = void 0;
      this.load();
    });
    observer.observe(target);
    dispose = onDispose(() => observer.disconnect());
  }
}

export { $signal as $, Icon as I, LayoutIconsLoader as L, SlotManager as S };
