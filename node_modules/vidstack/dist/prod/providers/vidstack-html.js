import { f as isHLSSrc, g as isMediaStream } from '../chunks/vidstack-XO9MYVWR.js';
import { M as useDisposalBin, e as effect, o as onDispose, l as listenEvent, u as peek, N as isNil, D as DOMEvent, x as createScope, s as setAttribute, t as isString } from '../chunks/vidstack-DoOmgEfT.js';
import { R as RAFLoop } from '../chunks/vidstack-BhYx9Fjk.js';
import { g as getNumberOfDecimalPlaces } from '../chunks/vidstack-ksPACRiU.js';
import { a as IS_IOS, h as IS_SAFARI } from '../chunks/vidstack-B_9E7csz.js';
import { L as ListSymbol } from '../chunks/vidstack-CerDQCFL.js';

class HTMLMediaEvents {
  constructor(_provider, _ctx) {
    this.i = _provider;
    this.b = _ctx;
    this.sa = useDisposalBin();
    this.Cb = false;
    this.$c = false;
    this.ad = false;
    this.Da = new RAFLoop(this.bd.bind(this));
    this.Qe = void 0;
    this.Dg = void 0;
    this.pg();
    effect(this.qg.bind(this));
    onDispose(this.cd.bind(this));
  }
  get a() {
    return this.i.media;
  }
  get c() {
    return this.b.delegate.c;
  }
  cd() {
    this.$c = false;
    this.ad = false;
    this.Da.ra();
    this.sa.empty();
  }
  /**
   * The `timeupdate` event fires surprisingly infrequently during playback, meaning your progress
   * bar (or whatever else is synced to the currentTime) moves in a choppy fashion. This helps
   * resolve that by retrieving time updates in a request animation frame loop.
   */
  bd() {
    const newTime = this.a.currentTime;
    if (this.b.$state.realCurrentTime() !== newTime)
      this.$a(newTime);
  }
  pg() {
    this.t("loadstart", this.Ea);
    this.t("abort", this.Pe);
    this.t("emptied", this.rg);
    this.t("error", this.U);
    this.t("volumechange", this.ab);
  }
  sg() {
    if (this.$c)
      return;
    this.sa.add(
      this.t("loadeddata", this.tg),
      this.t("loadedmetadata", this.ug),
      this.t("canplay", this.hc),
      this.t("canplaythrough", this.vg),
      this.t("durationchange", this.wg),
      this.t("play", this.xb),
      this.t("progress", this.ic),
      this.t("stalled", this.xg),
      this.t("suspend", this.yg),
      this.t("ratechange", this.Bg)
    );
    this.$c = true;
  }
  zg() {
    if (this.ad)
      return;
    this.sa.add(
      this.t("pause", this.Aa),
      this.t("playing", this.Ag),
      this.t("seeked", this.bb),
      this.t("seeking", this.Cg),
      this.t("ended", this.Db),
      this.t("waiting", this.dd)
    );
    this.ad = true;
  }
  t(eventType, handler) {
    return listenEvent(
      this.a,
      eventType,
      handler.bind(this)
    );
  }
  Eg(event2) {
    return;
  }
  $a(time, trigger) {
    const detail = {
      // Avoid errors where `currentTime` can have higher precision.
      currentTime: Math.min(time, this.b.$state.seekableEnd()),
      played: this.a.played
    };
    this.c("time-update", detail, trigger);
  }
  Ea(event2) {
    if (this.a.networkState === 3) {
      this.Pe(event2);
      return;
    }
    this.sg();
    this.c("load-start", void 0, event2);
  }
  Pe(event2) {
    this.c("abort", void 0, event2);
  }
  rg() {
    this.c("emptied", void 0, event);
  }
  tg(event2) {
    this.c("loaded-data", void 0, event2);
  }
  ug(event2) {
    this.zg();
    this.c("loaded-metadata", void 0, event2);
    if (IS_IOS || IS_SAFARI && isHLSSrc(this.b.$state.source())) {
      this.b.delegate.jc(this.ed(), event2);
    }
  }
  ed() {
    return {
      provider: peek(this.b.$provider),
      duration: this.a.duration,
      buffered: this.a.buffered,
      seekable: this.a.seekable
    };
  }
  xb(event2) {
    if (!this.b.$state.canPlay)
      return;
    this.c("play", void 0, event2);
  }
  Aa(event2) {
    if (this.a.readyState === 1 && !this.Cb)
      return;
    this.Cb = false;
    this.Da.ra();
    this.c("pause", void 0, event2);
  }
  hc(event2) {
    this.b.delegate.jc(this.ed(), event2);
  }
  vg(event2) {
    if (this.b.$state.started())
      return;
    this.c("can-play-through", this.ed(), event2);
  }
  Ag(event2) {
    this.Cb = false;
    this.c("playing", void 0, event2);
    this.Da.Bb();
  }
  xg(event2) {
    this.c("stalled", void 0, event2);
    if (this.a.readyState < 3) {
      this.Cb = true;
      this.c("waiting", void 0, event2);
    }
  }
  dd(event2) {
    if (this.a.readyState < 3) {
      this.Cb = true;
      this.c("waiting", void 0, event2);
    }
  }
  Db(event2) {
    this.Da.ra();
    this.$a(this.a.duration, event2);
    this.c("end", void 0, event2);
    if (this.b.$state.loop()) {
      const hasCustomControls = isNil(this.a.controls);
      if (hasCustomControls)
        this.a.controls = false;
    }
  }
  qg() {
    if (this.b.$state.paused()) {
      listenEvent(this.a, "timeupdate", this.Eb.bind(this));
    }
  }
  Eb(event2) {
    this.$a(this.a.currentTime, event2);
  }
  wg(event2) {
    if (this.b.$state.ended()) {
      this.$a(this.a.duration, event2);
    }
    this.c("duration-change", this.a.duration, event2);
  }
  ab(event2) {
    const detail = {
      volume: this.a.volume,
      muted: this.a.muted
    };
    this.c("volume-change", detail, event2);
  }
  bb(event2) {
    this.$a(this.a.currentTime, event2);
    this.c("seeked", this.a.currentTime, event2);
    if (Math.trunc(this.a.currentTime) === Math.trunc(this.a.duration) && getNumberOfDecimalPlaces(this.a.duration) > getNumberOfDecimalPlaces(this.a.currentTime)) {
      this.$a(this.a.duration, event2);
      if (!this.a.ended) {
        this.b.player.dispatch(
          new DOMEvent("media-play-request", {
            trigger: event2
          })
        );
      }
    }
  }
  Cg(event2) {
    this.c("seeking", this.a.currentTime, event2);
  }
  ic(event2) {
    const detail = {
      buffered: this.a.buffered,
      seekable: this.a.seekable
    };
    this.c("progress", detail, event2);
  }
  yg(event2) {
    this.c("suspend", void 0, event2);
  }
  Bg(event2) {
    this.c("rate-change", this.a.playbackRate, event2);
  }
  U(event2) {
    const error = this.a.error;
    if (!error)
      return;
    const detail = {
      message: error.message,
      code: error.code,
      mediaError: error
    };
    this.c("error", detail, event2);
  }
}

class NativeAudioTracks {
  constructor(_provider, _ctx) {
    this.i = _provider;
    this.b = _ctx;
    this.Fb.onaddtrack = this.Fg.bind(this);
    this.Fb.onremovetrack = this.Gg.bind(this);
    this.Fb.onchange = this.Hg.bind(this);
    listenEvent(this.b.audioTracks, "change", this.Ig.bind(this));
  }
  get Fb() {
    return this.i.media.audioTracks;
  }
  Fg(event) {
    const _track = event.track;
    if (_track.label === "")
      return;
    const audioTrack = {
      id: _track.id.toString(),
      label: _track.label,
      language: _track.language,
      kind: _track.kind,
      selected: false
    };
    this.b.audioTracks[ListSymbol.oa](audioTrack, event);
    if (_track.enabled)
      audioTrack.selected = true;
  }
  Gg(event) {
    const track = this.b.audioTracks.getById(event.track.id);
    if (track)
      this.b.audioTracks[ListSymbol.Yb](track, event);
  }
  Hg(event) {
    let enabledTrack = this.Re();
    if (!enabledTrack)
      return;
    const track = this.b.audioTracks.getById(enabledTrack.id);
    if (track)
      this.b.audioTracks[ListSymbol.pa](track, true, event);
  }
  Re() {
    return Array.from(this.Fb).find((track) => track.enabled);
  }
  Ig(event) {
    const { current } = event.detail;
    if (!current)
      return;
    const track = this.Fb.getTrackById(current.id);
    if (track) {
      const prev = this.Re();
      if (prev)
        prev.enabled = false;
      track.enabled = true;
    }
  }
}

class HTMLMediaProvider {
  constructor(_media, _ctx) {
    this.a = _media;
    this.b = _ctx;
    this.scope = createScope();
    this.V = null;
  }
  setup() {
    new HTMLMediaEvents(this, this.b);
    if ("audioTracks" in this.media)
      new NativeAudioTracks(this, this.b);
    onDispose(() => {
      this.a.srcObject = null;
      this.a.removeAttribute("src");
      for (const source of this.a.querySelectorAll("source"))
        source.remove();
      this.a.load();
    });
  }
  get type() {
    return "";
  }
  get media() {
    return this.a;
  }
  get currentSrc() {
    return this.V;
  }
  setPlaybackRate(rate) {
    this.a.playbackRate = rate;
  }
  async play() {
    return this.a.play();
  }
  async pause() {
    return this.a.pause();
  }
  setMuted(muted) {
    this.a.muted = muted;
  }
  setVolume(volume) {
    this.a.volume = volume;
  }
  setCurrentTime(time) {
    this.a.currentTime = time;
  }
  setPlaysInline(inline) {
    setAttribute(this.a, "playsinline", inline);
  }
  async loadSource({ src, type }, preload) {
    this.a.preload = preload || "";
    if (isMediaStream(src)) {
      this.Bn();
      this.a.srcObject = src;
    } else {
      this.a.srcObject = null;
      if (isString(src)) {
        if (type !== "?") {
          this.yn({ src, type });
        } else {
          this.Bn();
          this.a.src = this.Ik(src);
        }
      } else {
        this.Bn();
        this.a.src = window.URL.createObjectURL(src);
      }
    }
    this.a.load();
    this.V = {
      src,
      type
    };
  }
  /**
   * Append source so it works when requesting AirPlay since hls.js will remove it.
   */
  yn(src, defaultType) {
    const prevSource = this.a.querySelector("source[data-vds]"), source = prevSource ?? document.createElement("source");
    setAttribute(source, "src", this.Ik(src.src));
    setAttribute(source, "type", src.type !== "?" ? src.type : defaultType);
    setAttribute(source, "data-vds", "");
    if (!prevSource)
      this.a.append(source);
  }
  Bn() {
    this.a.querySelector("source[data-vds]")?.remove();
  }
  Ik(src) {
    const { clipStartTime, clipEndTime } = this.b.$state, startTime = clipStartTime(), endTime = clipEndTime();
    if (startTime > 0 && endTime > 0) {
      return `${src}#t=${startTime},${endTime}`;
    } else if (startTime > 0) {
      return `${src}#t=${startTime}`;
    } else if (endTime > 0) {
      return `${src}#t=0,${endTime}`;
    }
    return src;
  }
}

export { HTMLMediaProvider };
